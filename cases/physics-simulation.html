<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>物理模拟 - ThreeJS XR 测试案例</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            pointer-events: none;
            text-shadow: 0 0 5px black;
        }
        #back-button {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 8px 12px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: Arial, sans-serif;
            z-index: 100;
        }
        #back-button:hover {
            background-color: rgba(0, 0, 0, 0.8);
        }
        #vr-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 12px 20px;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: Arial, sans-serif;
            font-weight: bold;
            z-index: 100;
        }
        #vr-button:hover {
            background-color: #0b7dda;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            z-index: 100;
        }
        button {
            margin: 5px;
            padding: 8px 12px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
    </style>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>
</head>
<body>
    <div id="info">物理模拟 - 在XR环境中的物理模拟，包括重力、碰撞和弹性效果</div>
    <button id="back-button" onclick="window.location.href='../index.html'">返回</button>
    <button id="vr-button">进入 VR</button>
    <div id="controls">
        <button id="add-sphere">添加球体</button>
        <button id="add-cube">添加立方体</button>
        <button id="reset">重置场景</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import * as CANNON from 'cannon-es';

        // 场景初始化
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x505050);

        // 相机设置
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 3);

        // 渲染器设置
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        // VR按钮
        document.getElementById('vr-button').addEventListener('click', function() {
            document.body.appendChild(VRButton.createButton(renderer));
            document.getElementById('vr-button').style.display = 'none';
        });

        // 控制器
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1, 0);
        controls.update();

        // 光照设置
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 10, 2);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.left = -10;
        directionalLight.shadow.camera.right = 10;
        directionalLight.shadow.camera.top = 10;
        directionalLight.shadow.camera.bottom = -10;
        scene.add(directionalLight);

        // 物理世界设置
        const world = new CANNON.World();
        world.gravity.set(0, -9.82, 0); // 重力
        world.broadphase = new CANNON.NaiveBroadphase();
        world.solver.iterations = 10;

        // 物理对象和视觉对象的映射
        const meshes = [];
        const bodies = [];

        // 创建地面
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({ mass: 0 }); // 质量为0表示静态物体
        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2); // 旋转平面
        world.addBody(groundBody);

        // 地面网格
        const groundGeometry = new THREE.PlaneGeometry(20, 20);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.8 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // 网格辅助
        const gridHelper = new THREE.GridHelper(20, 20);
        scene.add(gridHelper);

        // 创建斜坡
        const rampShape = new CANNON.Box(new CANNON.Vec3(2, 0.2, 4));
        const rampBody = new CANNON.Body({ mass: 0 });
        rampBody.addShape(rampShape);
        rampBody.position.set(0, 1, -2);
        rampBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 10); // 倾斜
        world.addBody(rampBody);

        // 斜坡网格
        const rampGeometry = new THREE.BoxGeometry(4, 0.4, 8);
        const rampMaterial = new THREE.MeshStandardMaterial({ color: 0xa0a0a0, roughness: 0.5 });
        const ramp = new THREE.Mesh(rampGeometry, rampMaterial);
        ramp.position.copy(new THREE.Vector3(rampBody.position.x, rampBody.position.y, rampBody.position.z));
        ramp.quaternion.copy(new THREE.Quaternion(rampBody.quaternion.x, rampBody.quaternion.y, rampBody.quaternion.z, rampBody.quaternion.w));
        ramp.castShadow = true;
        ramp.receiveShadow = true;
        scene.add(ramp);

        // 创建墙壁
        function createWall(x, y, z, width, height, depth) {
            const wallShape = new CANNON.Box(new CANNON.Vec3(width/2, height/2, depth/2));
            const wallBody = new CANNON.Body({ mass: 0 });
            wallBody.addShape(wallShape);
            wallBody.position.set(x, y, z);
            world.addBody(wallBody);

            const wallGeometry = new THREE.BoxGeometry(width, height, depth);
            const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x808080, roughness: 0.5 });
            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.position.copy(new THREE.Vector3(wallBody.position.x, wallBody.position.y, wallBody.position.z));
            wall.castShadow = true;
            wall.receiveShadow = true;
            scene.add(wall);
        }

        // 创建围墙
        createWall(0, 0.5, 10, 20, 1, 0.5); // 后墙
        createWall(0, 0.5, -10, 20, 1, 0.5); // 前墙
        createWall(10, 0.5, 0, 0.5, 1, 20); // 右墙
        createWall(-10, 0.5, 0, 0.5, 1, 20); // 左墙

        // 创建物理球体
        function createSphere(radius, position) {
            const sphereShape = new CANNON.Sphere(radius);
            const sphereBody = new CANNON.Body({
                mass: 1,
                position: new CANNON.Vec3(position.x, position.y, position.z),
                shape: sphereShape,
                material: new CANNON.Material({ restitution: 0.7 }) // 弹性
            });
            world.addBody(sphereBody);
            bodies.push(sphereBody);

            const sphereGeometry = new THREE.SphereGeometry(radius, 32, 32);
            const sphereMaterial = new THREE.MeshStandardMaterial({
                color: Math.random() * 0xffffff,
                roughness: 0.3,
                metalness: 0.2
            });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere.castShadow = true;
            sphere.receiveShadow = true;
            scene.add(sphere);
            meshes.push(sphere);

            return { body: sphereBody, mesh: sphere };
        }

        // 创建物理立方体
        function createBox(size, position) {
            const boxShape = new CANNON.Box(new CANNON.Vec3(size.x/2, size.y/2, size.z/2));
            const boxBody = new CANNON.Body({
                mass: 1,
                position: new CANNON.Vec3(position.x, position.y, position.z),
                shape: boxShape,
                material: new CANNON.Material({ restitution: 0.3 }) // 弹性
            });
            world.addBody(boxBody);
            bodies.push(boxBody);

            const boxGeometry = new THREE.BoxGeometry(size.x, size.y, size.z);
            const boxMaterial = new THREE.MeshStandardMaterial({
                color: Math.random() * 0xffffff,
                roughness: 0.5,
                metalness: 0.1
            });
            const box = new THREE.Mesh(boxGeometry, boxMaterial);
            box.castShadow = true;
            box.receiveShadow = true;
            scene.add(box);
            meshes.push(box);

            return { body: boxBody, mesh: box };
        }

        // 初始化一些物体
        createSphere(0.5, { x: 0, y: 5, z: 0 });
        createBox({ x: 0.8, y: 0.8, z: 0.8 }, { x: 1, y: 7, z: 1 });
        createSphere(0.3, { x: -1, y: 6, z: -1 });

        // 按钮事件
        document.getElementById('add-sphere').addEventListener('click', function() {
            const position = {
                x: (Math.random() - 0.5) * 4,
                y: 5 + Math.random() * 5,
                z: (Math.random() - 0.5) * 4
            };
            createSphere(0.2 + Math.random() * 0.5, position);
        });

        document.getElementById('add-cube').addEventListener('click', function() {
            const size = 0.3 + Math.random() * 0.5;
            const position = {
                x: (Math.random() - 0.5) * 4,
                y: 5 + Math.random() * 5,
                z: (Math.random() - 0.5) * 4
            };
            createBox({ x: size, y: size, z: size }, position);
        });

        document.getElementById('reset').addEventListener('click', function() {
            // 移除所有物体
            for (let i = 0; i < bodies.length; i++) {
                world.removeBody(bodies[i]);
                scene.remove(meshes[i]);
            }
            bodies.length = 0;
            meshes.length = 0;

            // 添加初始物体
            createSphere(0.5, { x: 0, y: 5, z: 0 });
            createBox({ x: 0.8, y: 0.8, z: 0.8 }, { x: 1, y: 7, z: 1 });
            createSphere(0.3, { x: -1, y: 6, z: -1 });
        });

        // VR控制器设置
        const controllerModelFactory = new XRControllerModelFactory();
        
        // 控制器1
        const controller1 = renderer.xr.getController(0);
        controller1.addEventListener('selectstart', onSelectStart);
        controller1.addEventListener('selectend', onSelectEnd);
        scene.add(controller1);

        const controllerGrip1 = renderer.xr.getControllerGrip(0);
        controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
        scene.add(controllerGrip1);

        // 控制器2
        const controller2 = renderer.xr.getController(1);
        controller2.addEventListener('selectstart', onSelectStart);
        controller2.addEventListener('selectend', onSelectEnd);
        scene.add(controller2);

        const controllerGrip2 = renderer.xr.getControllerGrip(1);
        controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
        scene.add(controllerGrip2);

        // 控制器射线辅助
        const geometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1)]);
        const line = new THREE.Line(geometry);
        line.scale.z = 5;

        controller1.add(line.clone());
        controller2.add(line.clone());

        // VR控制器交互
        function onSelectStart(event) {
            const controller = event.target;
            const position = new THREE.Vector3();
            position.setFromMatrixPosition(controller.matrixWorld);
            
            // 在控制器位置创建一个球体
            if (Math.random() > 0.5) {
                createSphere(0.2 + Math.random() * 0.3, position);
            } else {
                const size = 0.3 + Math.random() * 0.3;
                createBox({ x: size, y: size, z: size }, position);
            }
            
            // 振动反馈
            if (controller.gamepad) {
                controller.gamepad.hapticActuators[0].pulse(0.5, 100);
            }
        }

        function onSelectEnd() {}

        // 时钟和时间步长
        const clock = new THREE.Clock();
        const timeStep = 1 / 60;

        // 动画
        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render() {
            // 更新物理世界
            world.step(timeStep);

            // 更新网格位置
            for (let i = 0; i < bodies.length; i++) {
                meshes[i].position.copy(new THREE.Vector3(bodies[i].position.x, bodies[i].position.y, bodies[i].position.z));
                meshes[i].quaternion.copy(new THREE.Quaternion(bodies[i].quaternion.x, bodies[i].quaternion.y, bodies[i].quaternion.z, bodies[i].quaternion.w));
                
                // 如果物体掉出场景，将其重置
                if (bodies[i].position.y < -10) {
                    bodies[i].position.set(
                        (Math.random() - 0.5) * 4,
                        5 + Math.random() * 5,
                        (Math.random() - 0.5) * 4
                    );
                    bodies[i].velocity.set(0, 0, 0);
                    bodies[i].angularVelocity.set(0, 0, 0);
                }
            }

            renderer.render(scene, camera);
        }

        // 窗口大小调整
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        window.addEventListener('resize', onWindowResize);

        animate();
    </script>
</body>
</html>