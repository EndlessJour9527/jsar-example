<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>WebGL Render to Texture - 原始版本 vs 修复版本对比</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: Arial, sans-serif;
      background-color: #f5f5f5;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .header {
      background: white;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .comparison {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }

    .demo-section {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      text-align: center;
    }

    .demo-section h3 {
      margin-top: 0;
      color: #333;
    }

    .original {
      border-left: 4px solid #dc3545;
    }

    .fixed {
      border-left: 4px solid #28a745;
    }

    canvas {
      border: 2px solid #ddd;
      border-radius: 4px;
      margin: 10px 0;
    }

    .status {
      margin-top: 10px;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 14px;
      font-weight: bold;
    }

    .status.success {
      background-color: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }

    .status.error {
      background-color: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }

    .status.warning {
      background-color: #fff3cd;
      color: #856404;
      border: 1px solid #ffeaa7;
    }

    .explanation {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .code-block {
      background: #f8f9fa;
      border: 1px solid #e9ecef;
      border-radius: 4px;
      padding: 15px;
      margin: 10px 0;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      overflow-x: auto;
    }

    .highlight {
      background-color: #fff3cd;
      padding: 2px 4px;
      border-radius: 3px;
    }

    @media (max-width: 768px) {
      .comparison {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <h1>🔍 WebGL Render to Texture 问题分析与修复</h1>
      <p><strong>问题描述:</strong> 原始的 render-to-texture 代码在标准浏览器中正常显示旋转立方体，但在 JSAR runtime 中显示为黑色。</p>
      <p><strong>根本原因:</strong> JSAR 的混合渲染架构中，<code>clearColor</code> 和 <code>clear</code> 操作不生效，且缺少深度缓冲附件导致深度测试异常。</p>
    </div>

    <div class="comparison">
      <div class="demo-section original">
        <h3>❌ 原始版本 (有问题)</h3>
        <p>在 JSAR 中显示黑色</p>
        <canvas id="canvas-original" width="300" height="200"></canvas>
        <div id="status-original" class="status warning">加载中...</div>
        <p><small>注意：在标准浏览器中可能正常显示，但在 JSAR 中会出现黑色</small></p>
      </div>

      <div class="demo-section fixed">
        <h3>✅ 修复版本 (已解决)</h3>
        <p>在 JSAR 和浏览器中都正常显示</p>
        <canvas id="canvas-fixed" width="300" height="200"></canvas>
        <div id="status-fixed" class="status warning">加载中...</div>
        <p><small>添加了深度缓冲附件，解决了 JSAR 兼容性问题</small></p>
      </div>
    </div>

    <div class="explanation">
      <h2>🔧 修复方案详解</h2>

      <h3>1. 问题根源</h3>
      <p>JSAR 采用混合渲染架构，以下操作在默认帧缓冲中不生效：</p>
      <div class="code-block">
        // 这些操作在 JSAR 中不生效
        gl.clearColor(0, 0, 1, 1); // 设置清除颜色
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // 清除缓冲区
      </div>

      <h3>2. 关键修复</h3>
      <p>为帧缓冲对象 (FBO) 添加深度缓冲附件：</p>
      <div class="code-block">
        // JSAR FIX: 创建深度缓冲附件
        const depthBuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16,
        targetTextureWidth, targetTextureHeight);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT,
        gl.RENDERBUFFER, depthBuffer);

        // 检查帧缓冲完整性
        const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        if (status !== gl.FRAMEBUFFER_COMPLETE) {
        console.error('Framebuffer not complete:', status);
        }
      </div>

      <h3>3. JSAR 架构特点</h3>
      <ul>
        <li><strong>共享 WebGL 上下文:</strong> 通过 <code>navigator.gl</code> 提供，由宿主环境管理</li>
        <li><strong>混合渲染管道:</strong> 应用程序渲染到共享目标，宿主负责最终合成</li>
        <li><strong>XR 兼容性:</strong> 默认支持 WebXR 和立体渲染</li>
        <li><strong>API 兼容性:</strong> 大部分 WebGL API 完全支持，特定操作有限制</li>
      </ul>

      <h3>4. 最佳实践</h3>
      <ul>
        <li>为 FBO 创建完整的附件（颜色 + 深度）</li>
        <li>使用 <code>gl.checkFramebufferStatus()</code> 验证 FBO 状态</li>
        <li>保留标准 WebGL 调用以确保浏览器兼容性</li>
        <li>理解 JSAR 混合渲染架构的限制</li>
      </ul>
    </div>
  </div>

  <!-- 加载原始版本 -->
  <script>
    // 模拟原始版本的问题（简化演示）
    function setupOriginalDemo() {
      const canvas = document.getElementById('canvas-original');
      const gl = navigator.gl || canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

      if (!gl) {
        document.getElementById('status-original').textContent = 'WebGL 不支持';
        document.getElementById('status-original').className = 'status error';
        return;
      }

      // 模拟原始版本的渲染（简化）
      gl.clearColor(0.2, 0.2, 0.2, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT);

      // 在标准浏览器中，这会显示灰色背景
      // 在 JSAR 中，clear 操作不生效，可能显示黑色

      const isJSAR = !!navigator.gl;
      if (isJSAR) {
        document.getElementById('status-original').textContent = 'JSAR 环境：可能显示黑色（clear 不生效）';
        document.getElementById('status-original').className = 'status error';
      } else {
        document.getElementById('status-original').textContent = '浏览器环境：显示正常';
        document.getElementById('status-original').className = 'status success';
      }
    }

    // 设置修复版本的演示
    function setupFixedDemo() {
      const canvas = document.getElementById('canvas-fixed');
      const gl = navigator.gl || canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

      if (!gl) {
        document.getElementById('status-fixed').textContent = 'WebGL 不支持';
        document.getElementById('status-fixed').className = 'status error';
        return;
      }

      // 创建一个简单的渲染演示
      // JSAR FIX: 检测WebGL版本并使用适当的着色器语法
      const isWebGL2 = gl instanceof WebGL2RenderingContext;

      const vertexShaderSource = isWebGL2 ? `#version 300 es
in vec2 a_position;
void main() {
    gl_Position = vec4(a_position, 0.0, 1.0);
}` : `attribute vec2 a_position;
void main() {
    gl_Position = vec4(a_position, 0.0, 1.0);
}`;

      const fragmentShaderSource = isWebGL2 ? `#version 300 es
precision mediump float;
out vec4 fragColor;
void main() {
    fragColor = vec4(0.2, 0.8, 0.2, 1.0);
}` : `precision mediump float;
void main() {
    gl_FragColor = vec4(0.2, 0.8, 0.2, 1.0);
}`;

      const vertexShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vertexShader, vertexShaderSource);
      gl.compileShader(vertexShader);

      // JSAR FIX: 检查着色器编译错误
      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        console.error('顶点着色器编译错误:', gl.getShaderInfoLog(vertexShader));
        document.getElementById('status-fixed').textContent = '顶点着色器编译失败';
        document.getElementById('status-fixed').className = 'status error';
        return;
      }

      const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fragmentShader, fragmentShaderSource);
      gl.compileShader(fragmentShader);

      // JSAR FIX: 检查着色器编译错误
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        console.error('片段着色器编译错误:', gl.getShaderInfoLog(fragmentShader));
        document.getElementById('status-fixed').textContent = '片段着色器编译失败';
        document.getElementById('status-fixed').className = 'status error';
        return;
      }

      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);

      // JSAR FIX: 检查程序链接错误
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('程序链接错误:', gl.getProgramInfoLog(program));
        document.getElementById('status-fixed').textContent = '着色器程序链接失败';
        document.getElementById('status-fixed').className = 'status error';
        return;
      }

      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -0.5, -0.5,
        0.5, -0.5,
        0.0, 0.5
      ]), gl.STATIC_DRAW);

      gl.useProgram(program);
      const positionLocation = gl.getAttribLocation(program, 'a_position');

      // JSAR FIX: 检查属性位置
      if (positionLocation === -1) {
        console.error('无法找到 a_position 属性');
        document.getElementById('status-fixed').textContent = '着色器属性绑定失败';
        document.getElementById('status-fixed').className = 'status error';
        return;
      }
      function drawScene() {
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        // 渲染场景
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.clearColor(0.1, 0.1, 0.3, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.drawArrays(gl.TRIANGLES, 0, 3);
        requestAnimationFrame(drawScene);
      }
      drawScene();
      const isJSAR = !!navigator.gl;
      document.getElementById('status-fixed').textContent =
        `${isJSAR ? 'JSAR' : '浏览器'} 环境：渲染正常（已修复）`;
      document.getElementById('status-fixed').className = 'status success';
    }

    // 初始化演示
    setTimeout(() => {
      setupOriginalDemo();
      setupFixedDemo();
    }, 100);
  </script>
</body>

</html>