<!--
Copyright (c) 2019 The Khronos Group Inc.
Use of this source code is governed by an MIT-style license that can be
found in the LICENSE.txt file.
-->
<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="../../resources/js-test-style.css" />
  <script type="module">
    // 使用动态导入加载依赖脚本

  </script>
  <title>bindAttribLocation with aliasing - inactive attributes</title>
</head>

<body>
  <div id="description"></div>
  <div id="console"></div>
  <canvas id="canvas" width="8" height="8" style="width: 8px; height: 8px;"></canvas>
  <script id="vertexShaderStaticallyUsedButInactive" type="text/something-not-javascript">#version 300 es
precision mediump float;
in $(type_1) a_1;
in $(type_2) a_2;
void main() {
    gl_Position = true ? $(gl_Position_1) : $(gl_Position_2);
}
</script>
  <script id="vertexShaderUnused" type="text/something-not-javascript">#version 300 es
precision mediump float;
in $(type_1) a_1;
in $(type_2) a_2;
void main() {
    gl_Position = vec4(0.0);
}
</script>
  <script type="module">
    "use strict";
    
    // 导入所需的模块
    import { description, debug, finishTest, testPassed, testFailed, assertMsg } from '../../js/js-test-pre.js';
    import { WebGLTestUtils } from '../../js/webgl-test-utils.js';
    import { runBindAttribLocationAliasingTest } from '../../js/tests/gl-bindattriblocation-aliasing.js';
    
    description("This test verifies combinations of valid inactive attributes cannot be bound to the same location with bindAttribLocation. GLSL ES 3.00.6 section 12.46.");
    var wtu = WebGLTestUtils;
    var canvas = document.getElementById("canvas");
    var gl = wtu.create3DContext(canvas, { antialias: false }, 2);
    var glFragmentShader = wtu.loadShader(gl, wtu.simpleColorFragmentShaderESSL300, gl.FRAGMENT_SHADER);

    debug("Testing with shader that has statically used but inactive attributes.");
    runBindAttribLocationAliasingTest(wtu, gl, glFragmentShader, wtu.getScript('vertexShaderStaticallyUsedButInactive'));

    debug("");
    debug("Testing with shader that has entirely unused attributes.");
    runBindAttribLocationAliasingTest(wtu, gl, glFragmentShader, wtu.getScript('vertexShaderUnused'));

    var successfullyParsed = true;
  </script>
  <script type="module">
    import { shouldBeTrue, _addSpan, _bufferedLogToConsole, RESULTS, notifyFinishedToHarness } from '../../js/js-test-pre.js';
    
    shouldBeTrue("successfullyParsed");
    _addSpan('<br /><span class="pass">TEST COMPLETE</span>');
    if (_jsTestPreVerboseLogging) {
        _bufferedLogToConsole('TEST COMPLETE');
    }

    {
        const e_results = document.createElement('div');
        let fails_class = 'pass';
        if (RESULTS.fail) {
            fails_class = 'fail';
        } else {
            const parseBoolean = v => v.toLowerCase().startsWith('t') || parseFloat(v) > 0;
            const params = new URLSearchParams(window.location.search);
            if (parseBoolean(params.get('runUntilFail') || '')) {
              setTimeout(() => {
                params.set('runCount', parseInt(params.get('runCount') || '0') + 1);
                const url = new URL(window.location.href);
                url.search = params.toString();
                window.location.href = url.toString();
              }, 100);
            }
        }
        e_results.classList.add('pass');
        e_results.innerHTML = `<p>TEST COMPLETE: ${RESULTS.pass} PASS, ` +
          `<span class="${fails_class}">${RESULTS.fail} FAIL</span></p>`;

        const e_desc = document.getElementById("description");
        e_desc.appendChild(e_results);
    }

    notifyFinishedToHarness()
  </script>
</body>

</html>