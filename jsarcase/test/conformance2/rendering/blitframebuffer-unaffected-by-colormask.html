<!--
Copyright (c) 2021 The Khronos Group Inc.
Use of this source code is governed by an MIT-style license that can be
found in the LICENSE.txt file.
-->

<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>BlitFramebuffer Should Be Unaffected by ColorMask</title>
<link rel="stylesheet" href="../../resources/js-test-style.css"/>
<script src="../../js/js-test-pre.js"></script>
<script src="../../js/webgl-test-utils.js"></script>
<script src="../../js/webgl-async-loader.js"></script>
</head>
<body>
<canvas id="canvas" width="8" height="8"></canvas>
<div id="description"></div>
<div id="console"></div>

<script type="module">
"use strict";
import * as loader from '../../js/webgl-async-loader.js';
const { waitForWebGLTestGlobals } = loader;

// å°†åŸå§‹æµ‹è¯•ä»£ç å°è£…ä¸ºå‡½æ•°
function runWebGLTest() {
  try {


const wtu = WebGLTestUtils;
description("This test verifies that the blitFramebuffer is unaffected by the colorMask state.");

debug('Regression test for <a href="https://crbug.com/1257769">https://crbug.com/1257769</a> and <a href="https://bugs.webkit.org/show_bug.cgi?id=220129">https://bugs.webkit.org/show_bug.cgi?id=220129</a>');

function allocateTexture(gl, size) {
    const tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    return tex;
}

function allocateFBO(gl, tex) {
    const fbo = gl.createFramebuffer();
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fbo);
    gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
    return fbo;
}

function run() {
    const gl = wtu.create3DContext("canvas", { antialias: false }, 2);

    if (!gl) {
        testFailed("WebGL context does not exist");
        finishTest();
        return;
    }

    const size = 8;

    testPassed("WebGL context exists");

    // Allocate source and destination textures and framebuffer objects.
    const sourceTex = allocateTexture(gl, size);
    const sourceFBO = allocateFBO(gl, sourceTex);

    const destTex = allocateTexture(gl, size);
    const destFBO = allocateFBO(gl, destTex);

    const program = wtu.setupColorQuad(gl);

    gl.bindFramebuffer(gl.FRAMEBUFFER, sourceFBO);

    // Clear the source framebuffer to red.
    gl.clearColor(1, 0, 0, 1);
    gl.colorMask(true, true, true, true);
    gl.clear(gl.COLOR_BUFFER_BIT);

    // Draw a transparent green quad.
    gl.useProgram(program);
    wtu.drawFloatColorQuad(gl, [ 0, 255, 0, 0 ]);

    // Clear the alpha channel.
    gl.colorMask(false, false, false, true);
    gl.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    // At this point, even setting the colorMask to all-true won't
    // work around the bug, since that state is latched inside ANGLE
    // only during draws / clears.

    // Blit source to dest.
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, destFBO);
    gl.blitFramebuffer(0, 0, size, size, 0, 0, size, size, gl.COLOR_BUFFER_BIT, gl.NEAREST);
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, destFBO);

    // Note that the on-screen canvas is always black - we don't blit the result to it.
    wtu.checkCanvas(gl, [ 0, 255, 0, 255 ], "should be green", 1);
    finishTest();
}


requestAnimationFrame(run);


    var successfullyParsed = true;
    console.log("âœ… WebGL test completed successfully!");
  } catch (error) {
    console.error("âŒ WebGL test failed:", error);
    if (typeof debug !== 'undefined') {
      debug("Test failed: " + error.message);
    }
  }
}

// ç¯å¢ƒæ£€æµ‹å‡½æ•°
function isJSARRuntime() {
  const checks = [
    () => typeof waitForWebGLTestGlobals !== 'undefined',
    () => typeof process !== 'undefined' && process.versions && process.versions.node,
    () => typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.includes('JSAR'),
    () => typeof global !== 'undefined' && global.process,
    () => typeof window === 'undefined' && typeof global !== 'undefined',
    () => typeof module !== 'undefined' && module.exports
  ];
  
  const result = checks.some(check => {
    try {
      return check();
    } catch (e) {
      return false;
    }
  });
  
  console.log('ğŸ” JSAR Runtime detection result:', result);
  return result;
}

// ç®€å•è½®è¯¢ç­‰å¾…å‡½æ•°
function waitForGlobalsSimple(globals, callback, maxAttempts = 300) {
  let attempts = 0;
  console.log('ğŸ”„ Starting simple polling for globals:', globals);
  
  function check() {
    attempts++;
    const available = [];
    const missing = [];
    
    globals.forEach(name => {
      try {
        if (typeof eval(name) !== 'undefined') {
          available.push(name);
        } else {
          missing.push(name);
        }
      } catch (e) {
        missing.push(name);
      }
    });
    
    if (missing.length === 0) {
      console.log('âœ… All globals available:', globals);
      callback();
    } else if (attempts >= maxAttempts) {
      console.error('âŒ Timeout waiting for globals. Available:', available, 'Missing:', missing);
    } else {
      if (attempts % 20 === 0 || attempts <= 5) {
        console.log(`â³ Waiting for globals... Available: [${available.join(', ')}], Missing: [${missing.join(', ')}] (${attempts}/${maxAttempts})`);
      }
      setTimeout(check, 50);
    }
  }
  
  check();
}

// æ™ºèƒ½åˆå§‹åŒ–
function initializeTest() {
  console.log("ğŸ” Checking environment and dependencies...");
  
  const isJSAR = isJSARRuntime();
  const hasAsyncLoader = typeof waitForWebGLTestGlobals !== 'undefined';
  const requiredGlobals = ['description', 'debug', 'WebGLTestUtils'];
  
  console.log("Environment info:", {
    isJSARRuntime: isJSAR,
    hasAsyncLoader: hasAsyncLoader,
    userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : 'N/A'
  });
  
  if (isJSAR || hasAsyncLoader) {
    console.log("ğŸ”„ JSAR Runtime environment detected, using async loader...");
    
    if (hasAsyncLoader) {
      waitForWebGLTestGlobals(runWebGLTest, {
        maxRetries: 300,
        retryInterval: 50,
        timeout: 15000,
        onTimeout: function() {
          console.error("âŒ Timeout: WebGL test dependencies not available after 15s");
          try {
            if (typeof debug !== 'undefined') {
              debug("Test failed: Timeout waiting for dependencies");
            }
          } catch (e) {
            console.error("Debug function not available:", e);
          }
        },
        onError: function() {
          console.error("âŒ Error: Failed to load WebGL test dependencies");
          try {
            if (typeof debug !== 'undefined') {
              debug("Test failed: Failed to load dependencies");
            }
          } catch (e) {
            console.error("Debug function not available:", e);
          }
        }
      });
    } else {
      console.log("â³ No async loader found, using simple polling...");
      waitForGlobalsSimple(requiredGlobals, runWebGLTest);
    }
  } else {
    console.log("ğŸŒ Browser environment detected, running test directly...");
    setTimeout(runWebGLTest, 500);
  }
}

// ç¡®ä¿DOMåŠ è½½å®Œæˆåå†åˆå§‹åŒ–
setTimeout(initializeTest, 500);

</script>

</body>
</html>
